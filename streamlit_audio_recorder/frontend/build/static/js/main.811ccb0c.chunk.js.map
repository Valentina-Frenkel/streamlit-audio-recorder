{"version":3,"sources":["audio-react-recorder-chunks/src/styles.module.css","audio-react-recorder-chunks/src/index.js","StreamlitAudioRecorder.tsx","index.tsx"],"names":["module","exports","RecordState","require","Object","freeze","START","PAUSE","STOP","NONE","AudioReactRecorder","props","init","a","leftchannel","rightchannel","recorder","recording","recordingLength","volume","audioInput","sampleRate","AudioContext","window","webkitAudioContext","context","analyser","canvas","canvasRef","current","canvasCtx","getContext","stream","tested","navigator","getUserMedia","webkitGetUserMedia","mozGetUserMedia","getStream","constraints","audio","video","mediaDevices","setUpRecording","createGain","createMediaStreamSource","createAnalyser","connect","createScriptProcessor","destination","self","onaudioprocess","e","left","inputBuffer","getChannelData","right","reduce","b","console","log","stop","getTracks","forEach","track","push","Float32Array","visualize","mergeBuffers","channelBuffer","result","offset","lng","length","i","buffer","set","interleave","leftChannel","rightChannel","inputIndex","index","writeUTFBytes","view","string","setUint8","charCodeAt","backgroundColor","foregroundColor","WIDTH","width","HEIGHT","height","CENTERX","CENTERY","fftSize","bufferLength","dataArray","Uint8Array","clearRect","draw","drawVisual","requestAnimationFrame","getByteTimeDomainData","fillStyle","fillRect","lineWidth","strokeStyle","beginPath","sliceWidth","x","y","moveTo","lineTo","stroke","setupMic","start","setInterval","leftBuffer","rightBuffer","interleaved","ArrayBuffer","DataView","setUint32","setUint16","setInt16","Streamlit","setComponentValue","onStop","type","closeMic","blob","Blob","audioUrl","URL","createObjectURL","url","pause","resume","getAudioTracks","disconnect","React","createRef","this","prevProps","prevState","state","checkState","previousState","doIfState","cb","canvasWidth","canvasHeight","className","ref","Component","defaultProps","StAudioRec","isFocused","recordState","audioDataURL","reset","render","theme","style","borderStyling","primaryColor","border","outline","id","onClick","onClick_start","onClick_stop","onClick_reset","onClick_continue","onStop_audio","controls","src","setState","datetime","Date","toLocaleString","filename","replace","document","createElement","display","href","download","body","appendChild","click","data","fetch","then","ctx","Response","arrayBuffer","StreamlitComponentBase","withStreamlitConnection","setComponentReady","setFrameHeight","ReactDOM","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.811ccb0c.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"test\":\"styles_test__2rKUN\"};","import React from 'react'\nimport styles from './styles.module.css'\nimport PropTypes from 'prop-types' // ES6\n\nimport {\n  Streamlit,\n  withStreamlitConnection,\n} from \"streamlit-component-lib\"\n\nconst fs = require('fs');\nconst path = require('path');\n\n// export const AudioReactRecorder = ({ text }) => {\n//   return <div className={styles.test}>BULLSWEET: {text}</div>\n// }\n\nexport const RecordState = Object.freeze({\n  START: 'start',\n  PAUSE: 'pause',\n  STOP: 'stop',\n  NONE: 'none'\n})\n\nexport default class AudioReactRecorder extends React.Component {\n  //0 - constructor\n  constructor(props) {\n    super(props)\n\n    this.canvasRef = React.createRef()\n  }\n\n  //TODO: add the props definitions\n  static propTypes = {\n    state: PropTypes.string,\n    type: PropTypes.string.isRequired,\n    backgroundColor: PropTypes.string,\n    foregroundColor: PropTypes.string,\n    canvasWidth: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n    canvasHeight: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n\n    //method calls\n    onStop: PropTypes.func\n  }\n  static defaultProps = {\n    state: RecordState.NONE,\n    type: 'audio/wav',\n    backgroundColor: 'rgb(200, 200, 200)',\n    foregroundColor: 'rgb(0, 0, 0)',\n    canvasWidth: 500,\n    canvasHeight: 300\n  }\n\n  //2 - mount\n  componentDidMount() {\n    this.init()\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    const { state } = this.props\n\n    this.checkState(prevProps.state, state)\n  }\n\n  checkState(previousState) {\n    switch (previousState) {\n      case RecordState.START:\n        this.doIfState(RecordState.PAUSE, this.pause)\n        this.doIfState(RecordState.STOP, this.stop)\n        break\n      case RecordState.PAUSE:\n        this.doIfState(RecordState.START, this.resume)\n        this.doIfState(RecordState.STOP, this.stop)\n        break\n      case RecordState.STOP:\n        this.doIfState(RecordState.START, this.start)\n        break\n      default:\n        this.doIfState(RecordState.START, this.start)\n        break\n    }\n  }\n\n  doIfState(state, cb) {\n    if (this.props.state == state) {\n      cb && cb()\n    }\n  }\n\n  //TODO: destroy request animation frame\n  componentWillUnmount() {}\n\n  //TODO: change to state some conditionals\n  init = async () => {\n    this.leftchannel = []\n    this.rightchannel = []\n    this.recorder = null\n    this.recording = false\n    this.recordingLength = 0\n    this.volume = null\n    this.audioInput = null\n    this.sampleRate = null\n    this.AudioContext = window.AudioContext || window.webkitAudioContext\n    this.context = null\n    this.analyser = null\n    this.canvas = this.canvasRef.current\n    this.canvasCtx = this.canvas.getContext('2d')\n    this.stream = null\n    this.tested = false\n\n    navigator.getUserMedia =\n      navigator.getUserMedia ||\n      navigator.webkitGetUserMedia ||\n      navigator.mozGetUserMedia\n  }\n\n  //get mic stream\n  getStream = (constraints) => {\n    if (!constraints) {\n      constraints = { audio: true, video: false }\n    }\n\n    return navigator.mediaDevices.getUserMedia(constraints)\n  }\n\n  setUpRecording = () => {\n    this.context = new this.AudioContext()\n    this.sampleRate = this.context.sampleRate\n\n    // creates a gain node\n    this.volume = this.context.createGain()\n\n    // creates an audio node from teh microphone incoming stream\n    this.audioInput = this.context.createMediaStreamSource(this.stream)\n\n    // Create analyser\n    this.analyser = this.context.createAnalyser()\n\n    // connect audio input to the analyser\n    this.audioInput.connect(this.analyser)\n\n    // connect analyser to the volume control\n    // analyser.connect(volume);\n\n    let bufferSize = 2048\n    this.recorder = this.context.createScriptProcessor(bufferSize, 2, 2)\n\n    // we connect the volume control to the processor\n    // volume.connect(recorder);\n\n    this.analyser.connect(this.recorder)\n\n    // finally connect the processor to the output\n    this.recorder.connect(this.context.destination)\n\n    const self = this\n    this.recorder.onaudioprocess = function (e) {\n      // Check\n      if (!self.recording) return\n      // Do something with the data, i.e Convert this to WAV\n      let left = e.inputBuffer.getChannelData(0)\n      let right = e.inputBuffer.getChannelData(1)\n      if (!self.tested) {\n        self.tested = true\n        // if this reduces to 0 we are not getting any sound\n        if (!left.reduce((a, b) => a + b)) {\n          console.log('Error: There seems to be an issue with your Mic')\n          // clean up;\n          self.stop()\n          self.stream.getTracks().forEach(function (track) {\n            track.stop()\n          })\n          // self.context.close() // error being thrown on this line\n        }\n      }\n      // we clone the samples\n      self.leftchannel.push(new Float32Array(left))\n      self.rightchannel.push(new Float32Array(right))\n      self.recordingLength += bufferSize\n    }\n    this.visualize()\n  }\n\n  mergeBuffers = (channelBuffer, recordingLength) => {\n    let result = new Float32Array(recordingLength)\n    let offset = 0\n    let lng = channelBuffer.length\n    for (let i = 0; i < lng; i++) {\n      let buffer = channelBuffer[i]\n      result.set(buffer, offset)\n      offset += buffer.length\n    }\n    return result\n  }\n\n  interleave = (leftChannel, rightChannel) => {\n    let length = leftChannel.length + rightChannel.length\n    let result = new Float32Array(length)\n\n    let inputIndex = 0\n\n    for (let index = 0; index < length; ) {\n      result[index++] = leftChannel[inputIndex]\n      result[index++] = rightChannel[inputIndex]\n      inputIndex++\n    }\n    return result\n  }\n\n  writeUTFBytes = (view, offset, string) => {\n    let lng = string.length\n    for (let i = 0; i < lng; i++) {\n      view.setUint8(offset + i, string.charCodeAt(i))\n    }\n  }\n\n  visualize = () => {\n    const { backgroundColor, foregroundColor } = this.props\n\n    this.WIDTH = this.canvas.width\n    this.HEIGHT = this.canvas.height\n    this.CENTERX = this.canvas.width / 2\n    this.CENTERY = this.canvas.height / 2\n\n    if (!this.analyser) return\n\n    this.analyser.fftSize = 2048\n    const bufferLength = this.analyser.fftSize\n    const dataArray = new Uint8Array(bufferLength)\n\n    this.canvasCtx.clearRect(0, 0, this.WIDTH, this.HEIGHT)\n\n    //reference this using self\n    let self = this\n    const draw = function () {\n      self.drawVisual = requestAnimationFrame(draw)\n\n      self.analyser.getByteTimeDomainData(dataArray)\n\n      self.canvasCtx.fillStyle = backgroundColor\n      self.canvasCtx.fillRect(0, 0, self.WIDTH, self.HEIGHT)\n\n      self.canvasCtx.lineWidth = 2\n      self.canvasCtx.strokeStyle = foregroundColor\n\n      self.canvasCtx.beginPath()\n\n      var sliceWidth = (self.WIDTH * 1.0) / bufferLength\n      var x = 0\n\n      for (var i = 0; i < bufferLength; i++) {\n        var v = dataArray[i] / 128.0\n        var y = (v * self.HEIGHT) / 2\n\n        if (i === 0) {\n          self.canvasCtx.moveTo(x, y)\n        } else {\n          self.canvasCtx.lineTo(x, y)\n        }\n\n        x += sliceWidth\n      }\n\n      self.canvasCtx.lineTo(self.canvas.width, self.canvas.height / 2)\n      self.canvasCtx.stroke()\n    }\n\n    draw()\n  }\n\n  setupMic = async () => {\n    //TODO: only get stream after clicking start\n    try {\n      window.stream = this.stream = await this.getStream()\n      //TODO: on got stream\n    } catch (err) {\n      //TODO: error getting stream\n      console.log('Error: Issue getting mic', err)\n    }\n\n    this.setUpRecording()\n  }\n\n  start = async () => {\n    await this.setupMic()\n\n    this.recording = true\n    // reset the buffers for the new recording\n    this.leftchannel.length = this.rightchannel.length = 0\n    this.recordingLength = 0\n\n\n\n\n\n\n\n    // Every 3 seconds for 5 loops, print logs\n    // let count = 0\n    let interval = setInterval(() => {\n      // count++\n      if (!this.recording) {\n        // clearInterval(interval)\n      }\n      console.log('Recording: ', this.recording)\n      // console.log('recordingLength: ', this.recordingLength)\n      \n      // we flat the left and right channels down\n      this.leftBuffer = this.mergeBuffers(this.leftchannel, this.recordingLength)\n      this.rightBuffer = this.mergeBuffers(\n        this.rightchannel,\n        this.recordingLength\n      )\n      // we interleave both channels together\n      let interleaved = this.interleave(this.leftBuffer, this.rightBuffer)\n      // we create our wav file\n      let buffer = new ArrayBuffer(44 + interleaved.length * 2)\n      let view = new DataView(buffer)\n\n      // RIFF chunk descriptor\n      this.writeUTFBytes(view, 0, 'RIFF')\n      view.setUint32(4, 44 + interleaved.length * 2, true)\n      this.writeUTFBytes(view, 8, 'WAVE')\n      // FMT sub-chunk\n      this.writeUTFBytes(view, 12, 'fmt ')\n      view.setUint32(16, 16, true)\n      view.setUint16(20, 1, true)\n      // stereo (2 channels)\n      view.setUint16(22, 2, true)\n      view.setUint32(24, this.sampleRate, true)\n      view.setUint32(28, this.sampleRate * 4, true)\n      view.setUint16(32, 4, true)\n      view.setUint16(34, 16, true)\n      // data sub-chunk\n      this.writeUTFBytes(view, 36, 'data')\n      view.setUint32(40, interleaved.length * 2, true)\n\n      // write the PCM samples\n      let lng = interleaved.length\n      let index = 44\n      let volume = 1\n      for (let i = 0; i < lng; i++) {\n        view.setInt16(index, interleaved[i] * (0x7fff * volume), true)\n        index += 2\n      }\n\n      // our final binary blob\n      // let blob_chunk = new Blob([buffer], { type: 'audio/wav'})\n      // console.log('blob: ', blob_chunk)\n\n      Streamlit.setComponentValue({\n        \"arr\": new Uint8Array(buffer)\n      })\n    }\n    , 1000)\n\n  }\n\n  stop = () => {\n    const { onStop, type } = this.props\n\n    this.recording = false\n    this.closeMic()\n\n    // we flat the left and right channels down\n    this.leftBuffer = this.mergeBuffers(this.leftchannel, this.recordingLength)\n    this.rightBuffer = this.mergeBuffers(\n      this.rightchannel,\n      this.recordingLength\n    )\n    // we interleave both channels together\n    let interleaved = this.interleave(this.leftBuffer, this.rightBuffer)\n\n    ///////////// WAV Encode /////////////////\n    // from http://typedarray.org/from-microphone-to-wav-with-getusermedia-and-web-audio/\n    //\n\n    // we create our wav file\n    let buffer = new ArrayBuffer(44 + interleaved.length * 2)\n    let view = new DataView(buffer)\n\n    // RIFF chunk descriptor\n    this.writeUTFBytes(view, 0, 'RIFF')\n    view.setUint32(4, 44 + interleaved.length * 2, true)\n    this.writeUTFBytes(view, 8, 'WAVE')\n    // FMT sub-chunk\n    this.writeUTFBytes(view, 12, 'fmt ')\n    view.setUint32(16, 16, true)\n    view.setUint16(20, 1, true)\n    // stereo (2 channels)\n    view.setUint16(22, 2, true)\n    view.setUint32(24, this.sampleRate, true)\n    view.setUint32(28, this.sampleRate * 4, true)\n    view.setUint16(32, 4, true)\n    view.setUint16(34, 16, true)\n    // data sub-chunk\n    this.writeUTFBytes(view, 36, 'data')\n    view.setUint32(40, interleaved.length * 2, true)\n\n    // write the PCM samples\n    let lng = interleaved.length\n    let index = 44\n    let volume = 1\n    for (let i = 0; i < lng; i++) {\n      view.setInt16(index, interleaved[i] * (0x7fff * volume), true)\n      index += 2\n    }\n\n    // our final binary blob\n    const blob = new Blob([view], { type: type })\n    const audioUrl = URL.createObjectURL(blob)\n\n    onStop &&\n      onStop({\n        blob: blob,\n        url: audioUrl,\n        type\n      })\n  }\n\n  pause = () => {\n    this.recording = false\n    this.closeMic()\n  }\n\n  resume = () => {\n    this.setupMic()\n    this.recording = true\n  }\n\n  closeMic = () => {\n    this.stream.getAudioTracks().forEach((track) => {\n      track.stop()\n    })\n    this.audioInput.disconnect(0)\n    this.analyser.disconnect(0)\n    this.recorder.disconnect(0)\n  }\n\n  //1 - render\n  render() {\n    const { canvasWidth, canvasHeight } = this.props\n\n    return (\n      <div className='audio-react-recorder'>\n        <canvas\n          ref={this.canvasRef}\n          width={canvasWidth}\n          height={canvasHeight}\n          className='audio-react-recorder__canvas'\n        ></canvas>\n      </div>\n    )\n  }\n}\n","import {\n  Streamlit,\n  StreamlitComponentBase,\n  withStreamlitConnection,\n} from \"streamlit-component-lib\"\nimport React, { ReactNode } from \"react\"\n\n// import AudioReactRecorder, { RecordState } from 'audio-react-recorder'\nimport AudioReactRecorder from './audio-react-recorder-chunks/src'\nimport { RecordState } from 'audio-react-recorder'\nimport 'audio-react-recorder/dist/index.css'\n\ninterface State {\n  isFocused: boolean\n  recordState: null\n  audioDataURL: string\n  reset: boolean\n}\n\nclass StAudioRec extends StreamlitComponentBase<State> {\n  public state = { isFocused: false, recordState: null, audioDataURL: '', reset: false}\n\n  public render = (): ReactNode => {\n    // Arguments that are passed to the plugin in Python are accessible\n\n    // Streamlit sends us a theme object via props that we can use to ensure\n    // that our component has visuals that match the active theme in a\n    // streamlit app.\n    const { theme } = this.props\n    const style: React.CSSProperties = {}\n\n    const { recordState } = this.state\n\n    // compatibility with older vers of Streamlit that don't send theme object.\n    if (theme) {\n      // Use the theme object to style our button border. Alternatively, the\n      // theme style is defined in CSS vars.\n      const borderStyling = `1px solid ${\n        this.state.isFocused ? theme.primaryColor : \"gray\"}`\n      style.border = borderStyling\n      style.outline = borderStyling\n    }\n\n    return (\n      <span>\n        <div>\n          <button id='record' onClick={this.onClick_start}>\n            Start Recording\n          </button>\n          <button id='stop' onClick={this.onClick_stop}>\n            Stop\n          </button>\n          <button id='reset' onClick={this.onClick_reset}>\n            Reset\n          </button>\n\n          <button id='continue' onClick={this.onClick_continue}>\n            Download\n          </button>\n\n          <AudioReactRecorder\n            state={recordState}\n            onStop={this.onStop_audio}\n            type='audio/wav'\n            backgroundColor='rgb(255, 255, 255)'\n            foregroundColor='rgb(255,76,75)'\n            canvasWidth={450}\n            canvasHeight={100}\n          />\n\n          <audio\n            id='audio'\n            controls\n            src={this.state.audioDataURL}\n          />\n\n        </div>\n      </span>\n    )\n  }\n\n\n  private onClick_start = () => {\n    this.setState({\n      reset: false,\n      audioDataURL: '',\n      recordState: RecordState.START\n    })\n    Streamlit.setComponentValue('')\n  }\n\n  private onClick_stop = () => {\n    this.setState({\n      reset: false,\n      recordState: RecordState.STOP\n    })\n  }\n\n  private onClick_reset = () => {\n    this.setState({\n      reset: true,\n      audioDataURL: '',\n      recordState: RecordState.STOP\n    })\n    Streamlit.setComponentValue('')\n  }\n\n  private onClick_continue = () => {\n    if (this.state.audioDataURL !== '')\n    {\n      // get datetime string for filename\n      let datetime = new Date().toLocaleString();\n      datetime = datetime.replace(' ', '');\n      datetime = datetime.replace(/_/g, '');\n      datetime = datetime.replace(',', '');\n      var filename = 'streamlit_audio_' + datetime + '.wav';\n\n      // auromatically trigger download\n      const a = document.createElement('a');\n      a.style.display = 'none';\n      a.href = this.state.audioDataURL;\n      a.download = filename;\n      document.body.appendChild(a);\n      a.click();\n    }\n  }\n\n  private onStop_audio = (data) => {\n    if (this.state.reset === true)\n    {\n      this.setState({\n        audioDataURL: ''\n      })\n      Streamlit.setComponentValue('')\n    }else{\n      this.setState({\n        audioDataURL: data.url\n      })\n\n      fetch(data.url).then(function(ctx){\n        return ctx.blob()\n      }).then(function(blob){\n        // converting blob to arrayBuffer, this process step needs to be be improved\n        // this operation's time complexity scales exponentially with audio length\n        return (new Response(blob)).arrayBuffer()\n      }).then(function(buffer){\n        Streamlit.setComponentValue({\n          \"arr\": new Uint8Array(buffer)\n        })\n      })\n\n    }\n\n\n  }\n}\n\n// \"withStreamlitConnection\" is a wrapper function. It bootstraps the\n// connection between your component and the Streamlit app, and handles\n// passing arguments from Python -> Component.\n// You don't need to edit withStreamlitConnection (but you're welcome to!).\nexport default withStreamlitConnection(StAudioRec)\n\n// Tell Streamlit we're ready to start receiving data. We won't get our\n// first RENDER_EVENT until we call this function.\nStreamlit.setComponentReady()\n\n// Finally, tell Streamlit to update our initial height. We omit the\n// `height` parameter here to have it default to our scrollHeight.\nStreamlit.setFrameHeight()\n","import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport StAudioRec from \"./StreamlitAudioRecorder\"\n\nReactDOM.render(\n  <React.StrictMode>\n    <StAudioRec />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n)\n"],"sourceRoot":""}